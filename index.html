<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hybrid Time & Task Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"> 
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light background */
            zoom: 0.55; /* Aggressive zoom-out to counteract forced scaling */
            -moz-transform: scale(0.55);
            -moz-transform-origin: top left;
        }
        .card {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }
        .task-item {
            padding: 12px;
            border-left-width: 4px; 
            transition: background-color 0.15s ease;
        }
        .status-pill {
            display: inline-flex;
            align-items: center;
            padding: 4px 10px;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
        }
        /* Custom styles for loading state */
        .loading-shimmer {
            background: #e0e0e0;
            background-image: linear-gradient(to right, #e0e0e0 0%, #f5f5f5 20%, #e0e0e0 40%, #e0e0e0 100%);
            background-repeat: no-repeat;
            background-size: 800px 104px; 
            animation-duration: 1.5s;
            animation-fill-mode: forwards; 
            animation-iteration-count: infinite;
            animation-name: shimmer;
            animation-timing-function: linear;
        }
        @keyframes shimmer {
            0% { background-position: -468px 0; }
            100% { background-position: 468px 0; }
        }
        .loading-text { color: transparent; }
        
        /* Mobile optimizations */
        @media (max-width: 640px) {
            /* â— FIX: Force max-width of container to 100% on small screens */
            #app-container {
                max-width: 100% !important;
                padding-left: 1rem;
                padding-right: 1rem;
            }
            .status-pill {
                font-size: 0.75rem;
                padding: 3px 8px;
            }
            .task-item {
                padding: 10px;
                /* Ensure vertical stacking and alignment on small screens */
                flex-direction: column;
                align-items: flex-start !important;
            }
            .task-item > div:last-child {
                margin-top: 8px;
                width: 100%; /* Forces button container to full width */
                justify-content: flex-end;
            }
            button {
                min-height: 44px; /* Touch-friendly size */
            }
        }
        /* FIX FOR PRINTING: 
         * Ensure only the report is visible and formatted for print.
         */
        @media print {
            .no-print {
                display: none !important;
            }
            /* Ensure the main report container takes up the full page */
            #log-report-container {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                margin: 0;
                padding: 20px;
                box-shadow: none; 
                page-break-after: always; 
            }
            .print-header {
                display: block !important;
                text-align: center;
                margin-bottom: 20px;
                padding-bottom: 10px;
                border-bottom: 2px solid #374151; /* Dark line under header */
            }
            .print-table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 15px;
            }
            .print-table th, .print-table td {
                border: 1px solid #ccc;
                padding: 8px;
                text-align: left;
            }
            .print-table th {
                background-color: #f3f4f6;
            }
            /* Ensure the main app container is not hidden */
            #app-container {
                width: 100% !important;
                max-width: none !important;
            }
        }
    </style>
</head>
<body class="p-4 sm:p-8 min-h-screen flex items-start justify-center">

    <div id="app-container" class="w-full max-w-4xl lg:max-6xl">
        <header class="text-center mb-6 no-print">
            <h1 class="text-3xl font-extrabold text-gray-900 mb-2">Hybrid Time & Task Dashboard</h1>
            <p class="text-xs text-gray-500 mb-4 break-words">Session User ID: <span id="user-id-display" class="font-mono text-xs loading-text loading-shimmer rounded">Initializing user...</span></p>
            <p class="text-md font-semibold text-indigo-600">âœ… ALL DATA IS NOW FULLY SYNCHRONIZED ACROSS YOUR DEVICES.</p>
        </header>

        <div class="bg-white card rounded-xl p-6 mb-8 no-print">
            <h2 class="text-xl font-bold mb-4 text-gray-700">Current Status (Synced)</h2>
            <div id="status-display" class="space-y-3">
                <p class="flex justify-between items-center text-sm font-medium">
                    Clock Status:
                    <span id="clock-status-pill" class="status-pill bg-gray-200 text-gray-700 loading-text loading-shimmer">Loading...</span>
                </p>
                <p class="flex justify-between items-center text-sm font-medium">
                    Break Status:
                    <span id="break-status-pill" class="status-pill bg-gray-200 text-gray-700 loading-text loading-shimmer">Loading...</span>
                </p>
            </div>
        </div>

        <div class="bg-white card rounded-xl p-6 mb-8 flex flex-col space-y-4 no-print">
            <h2 class="text-xl font-bold mb-2 text-gray-700">Quick Actions</h2>
            
            <button id="clock-toggle-btn" 
                    onclick="handleClockToggle()" 
                    class="w-full py-3 rounded-xl font-bold text-white transition duration-200 shadow-lg hover:shadow-xl disabled:opacity-50" disabled>
                Initializing...
            </button>
            
            <button id="break-toggle-btn" 
                    onclick="handleBreakToggle()" 
                    class="w-full py-3 rounded-xl font-bold text-gray-700 bg-yellow-400 hover:bg-yellow-500 transition duration-200 shadow-md disabled:opacity-50" disabled>
                Initializing...
            </button>
        </div>

        <div class="bg-indigo-600 card rounded-xl p-6 mb-8 text-white no-print">
            <h2 class="text-xl font-bold mb-2">Unreported Time Summary (Synced)</h2>
            <p id="report-since" class="text-sm opacity-75 mb-4">Last reported: <span id="last-reported-date" class="font-semibold loading-text loading-shimmer rounded">Loading date...</span></p>

            <div class="flex flex-col space-y-2 mb-4">
                <div class="flex justify-between items-center text-lg font-bold">
                    <span>Work Time:</span>
                    <span id="total-work-time" class="font-mono text-xl loading-text loading-shimmer rounded">00:00:00</span>
                </div>
                <div class="flex justify-between items-center text-sm">
                    <span>Break Time:</span>
                    <span id="total-break-time" class="font-mono loading-text loading-shimmer rounded">00:00:00</span>
                </div>
            </div>

            <button id="mark-reported-btn" onclick="handleMarkReported()" class="w-full bg-indigo-700 hover:bg-indigo-800 text-white font-semibold py-2 rounded-lg transition duration-150 disabled:opacity-50 no-print" disabled>
                Mark All as Reported
            </button>
        </div>

        <div class="bg-white card rounded-xl p-6 mb-8 no-print">
            <h2 class="text-xl font-bold mb-4 text-gray-700">Priority Tasks (Synced)</h2>
            <p class="text-xs text-gray-500 mb-4">This task list is synchronized across all your devices.</p>
            <div id="unfinished-tasks-list" class="space-y-2 mb-4">
                <p class="text-center py-6 text-gray-500" id="task-loading">Awaiting database connection...</p>
            </div>
            
            <div class="border-t pt-4 mt-4">
                <h3 class="text-lg font-semibold text-gray-700 mb-3">Add New Task</h3>
                <div class="flex space-x-2 mb-2">
                    <input type="text" id="new-task-text" placeholder="Task Description (e.g., Email Bob)" class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                    
                    <button id="calendar-toggle-btn" onclick="handleCalendarClick()" class="flex-shrink-0 p-2 text-gray-600 bg-gray-100 hover:bg-gray-200 rounded-lg transition duration-150" title="Toggle Due Date">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-calendar">
                            <rect width="18" height="18" x="3" y="4" rx="2" ry="2"/>
                            <line x1="16" x2="16" y1="2" y2="6"/>
                            <line x1="8" x2="8" y1="2" y2="6"/>
                            <line x1="3" x2="21" y1="10" y2="10"/>
                        </svg>
                    </button>
                    
                    <button id="add-task-btn" onclick="handleAddTask()" class="flex-shrink-0 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-150 disabled:opacity-50" disabled>
                        Add
                    </button>
                </div>

                <div id="due-date-container" class="mt-3 hidden">
                    <label for="new-due-date" class="text-sm font-medium text-gray-600">Select Due Date (Optional):</label>
                    <input type="date" id="new-due-date" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                </div>
            </div>
        </div>

        <div id="log-report-container" class="bg-white card rounded-xl p-6 mb-8">
            <div class="flex justify-between items-center mb-4 no-print">
                <h2 class="text-xl font-bold text-gray-700"><span id="log-view-title">Time Log Segments (For Reporting)</span></h2>
                <div class="flex space-x-2">
                    <button id="manage-logs-btn" onclick="handleLogViewToggle()" class="no-print bg-indigo-500 hover:bg-indigo-600 text-white text-sm font-semibold py-2 px-4 rounded-lg transition duration-150" title="Edit or Delete individual event logs">
                        Manage Log Events
                    </button>
                    <button id="print-report-btn" onclick="handlePrintReport()" class="no-print bg-green-500 hover:bg-green-600 text-white text-sm font-semibold py-2 px-4 rounded-lg transition duration-150 disabled:opacity-50" disabled>
                        Print Report
                    </button>
                </div>
            </div>
            
            <div id="log-history-list" class="space-y-2 text-sm max-h-96 overflow-y-auto p-2 border rounded-lg bg-gray-50">
                <p class="text-center py-4 text-gray-500" id="history-loading">Awaiting session data...</p>
                </div>
            <p id="log-footer-text" class="text-xs text-gray-500 mt-4 text-center no-print">Calculated time spans since the last report cutoff.</p>
        </div>


        <div id="message-box" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center p-4 z-50">
            <div class="bg-white rounded-xl shadow-2xl max-w-sm w-full p-6">
                <h3 id="message-title" class="text-xl font-bold mb-3 text-red-600">Alert</h3>
                <p id="message-content" class="text-gray-700 mb-4"></p>
                <button onclick="hideMessage()" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 rounded-lg">
                    OK
                </button>
            </div>
        </div>

        <div id="editLogModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
            <div class="bg-white rounded-xl shadow-2xl max-w-md w-full p-6">
                <h3 class="text-2xl font-bold mb-4 text-gray-800">Edit Log Event</h3>
                <p class="text-sm text-gray-600 mb-4">Adjust the timestamp for the selected event. This will automatically recalculate all reports.</p>
                
                <input type="hidden" id="editingLogId">
                <p class="font-semibold mb-2">Event Type: <span id="editingLogType" class="text-indigo-600"></span></p>

                <div class="mb-4">
                    <label for="editDate" class="block text-sm font-medium text-gray-700 mb-1">Date</label>
                    <input type="date" id="editDate" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                </div>

                <div class="mb-6">
                    <label for="editTime" class="block text-sm font-medium text-gray-700 mb-1">Time (24-hour format, HH:MM)</label>
                    <input type="time" id="editTime" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                
                <div class="flex justify-end space-x-3">
                    <button onclick="hideEditModal()" class="px-4 py-2 text-gray-600 bg-gray-100 hover:bg-gray-200 rounded-lg font-medium transition duration-150">
                        Cancel
                    </button>
                    <button onclick="handleSaveEdit()" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg font-medium transition duration-150">
                        Save Changes
                    </button>
                </div>
            </div>
        </div>
    </div>

<script type="module">
        // --- IMMEDIATE VIEWPORT FIX (MODIFIED) ---
        (function() {
            // 1. Force remove any existing viewport tag
            const metaTags = document.head.getElementsByTagName('meta');
            for (let i = metaTags.length - 1; i >= 0; i--) {
                if (metaTags[i].name === 'viewport') {
                    document.head.removeChild(metaTags[i]);
                }
            }
            
            // 2. Create the robust viewport tag and inject it
            const newMeta = document.createElement('meta');
            newMeta.name = 'viewport';
            // âœ… SIMPLIFIED FIX: Removed restrictive parameters to prevent OS blocking the tag
            newMeta.content = 'width=device-width, initial-scale=1.0'; 
            document.head.appendChild(newMeta);
        })(); 
        // -----------------------------
        
        // --- INJECTED FIREBASE CONFIGURATION (Original, Unchanged) ---
        const __app_id = '1:271808577978:web:c2e0f745681401fe4f1d83';
        const __firebase_config = '{"apiKey":"AIzaSyAGxZVLaHkowzF5ioMGGS9FnqMh31Zs5ds","authDomain":"timeclockapp-59694.firebaseapp.com","projectId":"timeclockapp-59694","storageBucket":"timeclockapp-59694.appspot.com","messagingSenderId":"271808577978","appId":"1:271808577978:web:c2e0f745681401fe4f1d83","measurementId":"G-6C1MRRFZTB"}';
        const __initial_auth_token = ""; 
        
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, addDoc, updateDoc, deleteDoc, query, orderBy, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- State and Constants ---
        let db;
        let auth;
        let userId = null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(__firebase_config);
        
        let currentState = {
            isClockedIn: false,
            isUserOnBreak: false,
            tasks: [], 
            lastReportTimestamp: null 
        };
        
        let currentReportData = { 
            segments: [], 
            totalWorkTime: '00:00:00', 
            totalBreakTime: '00:00:00',
            reportStartDate: new Date(), 
            reportEndDate: new Date() 
        };
        
        // NEW STATE: Stores the raw log events (with IDs) and controls the log view
        let rawLogEvents = [];
        let isManagingLogs = false; // False = show report segments, True = show raw events

        let showDatePicker = false;
        let newDueDate = null; // Stored as YYYY-MM-DD string

        // --- DOM Elements (Same as before) ---
        const clockToggleBtn = document.getElementById('clock-toggle-btn');
        const breakToggleBtn = document.getElementById('break-toggle-btn');
        const clockStatusPill = document.getElementById('clock-status-pill');
        const breakStatusPill = document.getElementById('break-status-pill');
        const tasksListEl = document.getElementById('unfinished-tasks-list');
        const taskLoadingEl = document.getElementById('task-loading');
        const userIdDisplayEl = document.getElementById('user-id-display');
        const logHistoryListEl = document.getElementById('log-history-list'); 
        const historyLoadingEl = document.getElementById('history-loading'); 
        const printReportBtn = document.getElementById('print-report-btn');
        const totalWorkTimeEl = document.getElementById('total-work-time'); 
        const totalBreakTimeEl = document.getElementById('total-break-time'); 
        const lastReportedDateEl = document.getElementById('last-reported-date'); 
        const markReportedBtn = document.getElementById('mark-reported-btn'); 
        const newTaskTextEl = document.getElementById('new-task-text');
        const addTaskBtn = document.getElementById('add-task-btn');
        const dueDateContainerEl = document.getElementById('due-date-container');
        const newDueDateEl = document.getElementById('new-due-date');
        const logViewTitleEl = document.getElementById('log-view-title');
        const logFooterTextEl = document.getElementById('log-footer-text');
        const manageLogsBtn = document.getElementById('manage-logs-btn');
        
        // Edit Modal Elements
        const editLogModal = document.getElementById('editLogModal');
        const editingLogIdEl = document.getElementById('editingLogId');
        const editingLogTypeEl = document.getElementById('editingLogType');
        const editDateEl = document.getElementById('editDate');
        const editTimeEl = document.getElementById('editTime');
        
        newDueDateEl.addEventListener('change', (e) => {
            newDueDate = e.target.value;
        });


        // --- Utility & UI Functions ---
        
        /**
         * Converts milliseconds to HH:MM:SS format.
         * IMPORTANT: Ensures the output is always positive.
         */
        function msToHours(ms) {
            // Use absolute value to prevent negative display time in summary
            const totalMs = Math.abs(ms); 
            const totalSeconds = Math.floor(totalMs / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        
        function renderReportSummary(workTime, breakTime) {
            totalWorkTimeEl.textContent = workTime;
            totalBreakTimeEl.textContent = breakTime;

            const ts = currentState.lastReportTimestamp;
            if (ts) {
                const date = new Date(ts).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                lastReportedDateEl.textContent = date;
            } else {
                lastReportedDateEl.textContent = 'Never (Showing All Time)';
            }
            // Remove loading placeholders once data is available
            totalWorkTimeEl.classList.remove('loading-text', 'loading-shimmer');
            totalBreakTimeEl.classList.remove('loading-text', 'loading-shimmer');
            lastReportedDateEl.classList.remove('loading-text', 'loading-shimmer');
        }

        function showMessage(title, content, isError = false) {
            const box = document.getElementById('message-box');
            const titleEl = document.getElementById('message-title');
            const contentEl = document.getElementById('message-content');
            
            titleEl.textContent = title;
            contentEl.textContent = content;

            titleEl.className = `text-xl font-bold mb-3 ${isError ? 'text-red-600' : 'text-green-600'}`;

            box.classList.remove('hidden');
            box.classList.add('flex');
        }

        window.hideMessage = function() {
            document.getElementById('message-box').classList.remove('flex');
            document.getElementById('message-box').classList.add('hidden');
        }
        
        window.hideEditModal = function() {
            editLogModal.classList.remove('flex');
            editLogModal.classList.add('hidden');
        }

        function renderStatus() {
            // Update UI based on currentState
            // Clock Status Pill
            if (currentState.isClockedIn) {
                clockStatusPill.textContent = 'CLOCKED IN';
                clockStatusPill.className = 'status-pill bg-green-100 text-green-700';
                clockToggleBtn.textContent = 'Clock OUT';
                clockToggleBtn.className = 'w-full py-3 rounded-xl font-bold text-white transition duration-200 shadow-lg hover:shadow-xl disabled:opacity-50 bg-red-600 hover:bg-red-700';
            } else {
                clockStatusPill.textContent = 'CLOCKED OUT';
                clockStatusPill.className = 'status-pill bg-red-100 text-red-700';
                clockToggleBtn.textContent = 'Clock IN';
                clockToggleBtn.className = 'w-full py-3 rounded-xl font-bold text-white transition duration-200 shadow-lg hover:shadow-xl disabled:opacity-50 bg-green-600 hover:bg-green-700';
            }

            // Break Status Pill & Button
            if (currentState.isUserOnBreak) {
                breakStatusPill.textContent = 'ON BREAK';
                breakStatusPill.className = 'status-pill bg-yellow-100 text-yellow-700';
                breakToggleBtn.textContent = 'Break END';
                breakToggleBtn.className = 'w-full py-3 rounded-xl font-bold text-gray-700 bg-yellow-400 hover:bg-yellow-500 transition duration-200 shadow-md disabled:opacity-50';
                breakToggleBtn.disabled = !currentState.isClockedIn;
            } else {
                breakStatusPill.textContent = 'WORKING';
                breakStatusPill.className = 'status-pill bg-indigo-100 text-indigo-700';
                breakToggleBtn.textContent = 'Break START';
                breakToggleBtn.className = 'w-full py-3 rounded-xl font-bold text-gray-700 bg-yellow-400 hover:bg-yellow-500 transition duration-200 shadow-md disabled:opacity-50';
                breakToggleBtn.disabled = !currentState.isClockedIn;
            }
        }
        
// ========================================
// NEW VERSION (Mobile & Desktop Optimized)
// ========================================
function renderTasks() {
    tasksListEl.innerHTML = '';
    
    currentState.tasks.sort((a, b) => {
        if (a.isCompleted !== b.isCompleted) {
            return a.isCompleted ? 1 : -1; 
        }
        const timeA = a.createdAt?.seconds ? a.createdAt.seconds * 1000 : new Date().getTime();
        const timeB = b.createdAt?.seconds ? b.createdAt.seconds * 1000 : new Date().getTime();
        return timeB - timeA; 
    });

    if (currentState.tasks.length === 0) {
        // âœ… Responsive text size (text-sm)
        tasksListEl.innerHTML = '<p class="text-center py-4 text-gray-500 text-sm">No shared tasks have been added yet.</p>';
        return;
    }

    currentState.tasks.forEach((task) => {
        const item = document.createElement('div');
        const completed = task.isCompleted;
        
        const itemClasses = completed 
            // âœ… items-start: aligns items at top, works better when buttons stack
            // âœ… NO justify-between: allows natural flow on mobile
            ? 'task-item bg-gray-200 rounded-lg flex items-start border-green-500'
            : 'task-item bg-white hover:bg-indigo-50 rounded-lg flex items-start border-indigo-500';

        item.className = itemClasses;
        
        const textContainer = document.createElement('div');
        // âœ… Responsive margin: mr-2 on mobile, mr-4 on larger screens
        textContainer.className = 'flex-grow mr-2 sm:mr-4 min-w-0';
        
        const textSpan = document.createElement('span');
        // âœ… Responsive text: text-xs on mobile, text-sm on larger screens
        textSpan.className = `text-xs sm:text-sm font-medium break-words ${completed ? 'text-gray-600 line-through' : 'text-gray-800'}`;
        textSpan.textContent = task.text;
        textContainer.appendChild(textSpan);
        
        if (task.dueDate) {
            const dueDateSpan = document.createElement('span');
            const dateObj = new Date(task.dueDate + 'T00:00:00');
            dueDateSpan.className = `text-xs mt-1 font-semibold block ${completed ? 'text-gray-400' : 'text-orange-500'}`;
            dueDateSpan.textContent = `Due: ${dateObj.toLocaleDateString()}`;
            textContainer.appendChild(dueDateSpan);
        }

        const creatorInfo = document.createElement('div');
        creatorInfo.className = 'text-xs mt-0.5 text-gray-500';
        creatorInfo.textContent = `By: ${task.ownerId ? task.ownerId.substring(0, 8) + '...' : 'Unknown'}`;
        textContainer.appendChild(creatorInfo);

        const buttonContainer = document.createElement('div');
        // âœ… Buttons stack vertically on mobile (flex-col), horizontal on desktop (sm:flex-row)
        // âœ… space-y-1 for vertical spacing, sm:space-x-2 for horizontal spacing
        // ðŸ‘‡ Using w-full for full width on mobile helps alignment
        buttonContainer.className = 'flex-shrink-0 flex flex-col sm:flex-row space-y-1 sm:space-y-0 sm:space-x-2 w-full sm:w-auto justify-end';

        const completeBtn = document.createElement('button');
        // âœ… active:scale-95 for touch feedback
        // âœ… Responsive padding: px-2 sm:px-3, py-1.5 sm:py-1
        completeBtn.className = `flex-shrink-0 text-white text-xs font-semibold px-2 sm:px-3 py-1.5 sm:py-1 rounded-full transition duration-150 shadow-md active:scale-95 ${completed ? 'bg-gray-500 hover:bg-gray-600' : 'bg-green-500 hover:bg-green-600'}`;
        completeBtn.textContent = completed ? 'Undo' : 'Done';
        completeBtn.onclick = () => toggleTaskCompletion(task.id, task.isCompleted);
        
        const deleteBtn = document.createElement('button');
        // âœ… active:scale-95 for touch feedback
        // âœ… Responsive padding: px-2 sm:px-3, py-1.5 sm:py-1
        deleteBtn.className = 'flex-shrink-0 text-white text-xs font-semibold px-2 sm:px-3 py-1.5 sm:py-1 rounded-full bg-red-500 hover:bg-red-600 transition duration-150 shadow-md active:scale-95';
        deleteBtn.textContent = 'Delete';
        deleteBtn.onclick = () => deleteTask(task.id);
        
        buttonContainer.appendChild(completeBtn);
        buttonContainer.appendChild(deleteBtn);

        item.appendChild(textContainer);
        item.appendChild(buttonContainer);
        tasksListEl.appendChild(item);
    });
}
// ========================================

        
        /**
         * Calculates total time and generates segments (spans) of work/break.
         */
        function calculateReportData(logs, sinceTimestamp) {
            let totalWorkMs = 0;
            let totalBreakMs = 0;
            let workStart = null;
            let breakStart = null;
            const segments = [];

            const filterCutoffMs = sinceTimestamp ? new Date(sinceTimestamp).getTime() : 0;
            // Filter logs to only include those that occurred *after* the last report timestamp
            const filteredLogs = logs.filter(log => new Date(log.timestamp).getTime() > filterCutoffMs);

            // Sort ascending by timestamp to process events chronologically
            filteredLogs.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

            // 1. Process historical logs and generate segments
            filteredLogs.forEach(log => {
                const timestamp = new Date(log.timestamp).getTime();

                switch (log.type) {
                    case 'CLOCK_IN':
                        if (breakStart !== null) {
                            const duration = timestamp - breakStart;
                            segments.push({ type: 'BREAK', start: new Date(breakStart), end: new Date(timestamp), durationMs: duration });
                            totalBreakMs += duration;
                            breakStart = null;
                        }
                        if (workStart === null) {
                            workStart = timestamp;
                        }
                        break;

                    case 'BREAK_START':
                        if (workStart !== null) {
                            const duration = timestamp - workStart;
                            segments.push({ type: 'WORK', start: new Date(workStart), end: new Date(timestamp), durationMs: duration });
                            totalWorkMs += duration;
                            workStart = null; 
                        }
                        if (breakStart === null) {
                            breakStart = timestamp;
                        }
                        break;

                    case 'BREAK_END':
                        if (breakStart !== null) {
                            const duration = timestamp - breakStart;
                            segments.push({ type: 'BREAK', start: new Date(breakStart), end: new Date(timestamp), durationMs: duration });
                            totalBreakMs += duration;
                            breakStart = null;
                        }
                        if (workStart === null) {
                            workStart = timestamp;
                        }
                        break;

                    case 'CLOCK_OUT':
                        if (workStart !== null) {
                            const duration = timestamp - workStart;
                            segments.push({ type: 'WORK', start: new Date(workStart), end: new Date(timestamp), durationMs: duration });
                            totalWorkMs += duration;
                            workStart = null;
                        }
                        if (breakStart !== null) {
                            const duration = timestamp - breakStart;
                            segments.push({ type: 'BREAK', start: new Date(breakStart), end: new Date(timestamp), durationMs: duration });
                            totalBreakMs += duration;
                            breakStart = null;
                        }
                        break;
                }
            });
            
            // 2. Add current active segment (if clocked in)
            if (currentState.isClockedIn) {
                const now = new Date();
                const nowMs = now.getTime();
                
                // Only consider segments that started *after* the report cutoff
                if (currentState.isUserOnBreak && breakStart !== null && breakStart > filterCutoffMs) {
                    const durationMs = nowMs - breakStart;
                    segments.push({ type: 'BREAK', start: new Date(breakStart), end: now, durationMs: durationMs, isLive: true });
                    totalBreakMs += durationMs;
                } else if (!currentState.isUserOnBreak && workStart !== null && workStart > filterCutoffMs) {
                    const durationMs = nowMs - workStart;
                    segments.push({ type: 'WORK', start: new Date(workStart), end: now, durationMs: durationMs, isLive: true });
                    totalWorkMs += durationMs;
                }
            }
            
            // Determine report dates for the title
            const startDate = filteredLogs.length > 0 ? new Date(filteredLogs[0].timestamp) : new Date();
            const endDate = new Date(); // Always current date

            // Sort segments by start time for the report view
            segments.sort((a, b) => a.start.getTime() - b.start.getTime());

            return {
                totalWorkTimeMs: totalWorkMs,
                totalBreakTimeMs: totalBreakMs,
                segments: segments,
                reportStartDate: startDate,
                reportEndDate: endDate
            };
        }
        
        /**
         * Renders the raw log events for editing/deletion.
         */
        function renderRawLogEvents() {
            logHistoryListEl.innerHTML = '';
            
            if (rawLogEvents.length === 0) {
                logHistoryListEl.innerHTML = '<p class="text-center py-4 text-gray-500">No time log events found.</p>';
                return;
            }

            // Sort descending by timestamp (most recent first)
            const sortedLogs = [...rawLogEvents].sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

            const table = document.createElement('table');
            table.className = 'print-table text-left w-full text-sm';
            
            table.innerHTML = `
                <thead class="bg-red-100">
                    <tr>
                        <th class="p-2">Event Type</th>
                        <th class="p-2">Timestamp</th>
                        <th class="p-2 text-right">Actions</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            `;
            const tbody = table.querySelector('tbody');

            sortedLogs.forEach(log => {
                const row = tbody.insertRow();
                
                const logTime = new Date(log.timestamp);
                const dateText = logTime.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                const timeText = logTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true });

                row.innerHTML = `
                    <td class="p-2 font-semibold">${log.type}</td>
                    <td class="p-2 text-gray-600">${dateText} at ${timeText}</td>
                    <td class="p-2 text-right space-x-2">
                        <button onclick="handleEditEvent('${log.id}', '${log.type}', '${log.timestamp}')" class="text-xs bg-indigo-500 hover:bg-indigo-600 text-white px-2 py-1 rounded">Edit</button>
                        <button onclick="handleDeleteEvent('${log.id}', '${log.type}')" class="text-xs bg-red-500 hover:bg-red-600 text-white px-2 py-1 rounded">Delete</button>
                    </td>
                `;
            });
            
            logHistoryListEl.appendChild(table);
        }

        /**
         * Renders the calculated time log segments (the report view).
         */
        function renderTimeLogSegments(segments, totalWorkTimeMs, totalBreakTimeMs) {
            logHistoryListEl.innerHTML = '';
            
            // Format dates for the title (e.g., Nov 26, 26)
            const dateOptions = { month: 'short', day: 'numeric', year: 'numeric' };
            const startDateFormatted = currentReportData.reportStartDate.toLocaleDateString('en-US', dateOptions);
            const endDateFormatted = currentReportData.reportEndDate.toLocaleDateString('en-US', dateOptions);
            
            // CALCULATE THE FINAL DISPLAY TOTAL by subtracting break time from work time
            const netWorkMs = totalWorkTimeMs - totalBreakTimeMs;
            const netWorkTimeFormatted = msToHours(netWorkMs); // Format the final value

            // --- 1. Print Header (CORRECTED STRUCTURE) ---
            const printHeaderContainer = document.createElement('div');
            // This class is targeted by the @media print CSS to be DISPLAYED.
            printHeaderContainer.className = 'print-header'; 
            
            printHeaderContainer.innerHTML = `
                <h1 class="text-xl font-bold mb-1">Time Log Report (${startDateFormatted} - ${endDateFormatted})</h1>
                <p class="text-sm">User ID: ${userId}</p>
                <p class="text-sm font-bold mt-2">TOTAL WORKED: ${netWorkTimeFormatted}</p>
                <p class="text-xs">Reported Since: ${lastReportedDateEl.textContent}</p>
            `;
            // Insert the header at the top of the report list container
            logHistoryListEl.prepend(printHeaderContainer); 

            // --- 2. Segment Table ---
            if (segments.length === 0) {
                const p = document.createElement('p');
                p.className = 'text-center py-4 text-gray-500';
                p.textContent = 'No new time segments found since the last report.';
                logHistoryListEl.appendChild(p);
                // Also update the UI summary to 00:00:00 if no data
                renderReportSummary('00:00:00', '00:00:00'); 
                return;
            }

            const table = document.createElement('table');
            table.className = 'print-table text-left w-full text-sm';
            
            table.innerHTML = `
                <thead class="bg-gray-200">
                    <tr>
                        <th class="p-2">Date</th>
                        <th class="p-2">Activity</th>
                        <th class="p-2">Start Time</th>
                        <th class="p-2">End Time</th>
                        <th class="p-2 text-right">Duration</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            `;
            const tbody = table.querySelector('tbody');

            segments.forEach(segment => {
                const row = tbody.insertRow();
                const date = segment.start.toLocaleDateString('en-US', dateOptions);
                const timeOptions = { hour: '2-digit', minute: '2-digit', hour12: true };
                const startTime = segment.start.toLocaleTimeString('en-US', timeOptions);
                
                // Use 'LIVE' or formatted time for end time
                const endTime = segment.isLive 
                    ? '<span class="text-indigo-500 font-semibold">LIVE</span>' 
                    : segment.end.toLocaleTimeString('en-US', timeOptions);
                
                const durationText = msToHours(segment.durationMs);
                
                let activityText;
                let colorClass;
                let durationDisplay;

                if (segment.type === 'WORK') {
                    activityText = 'Work';
                    colorClass = 'text-green-600';
                    durationDisplay = `<span class="font-bold">${durationText}</span>`;
                } else { // BREAK
                    activityText = 'Break';
                    colorClass = 'text-red-600';
                    // Display break time in parentheses
                    durationDisplay = `<span class="font-bold text-red-600">(${durationText})</span>`; 
                }
                
                // Check for negative duration (which can happen with inconsistent logs)
                if (segment.durationMs < 0) {
                     durationDisplay = `<span class="font-bold text-red-700">TIME CONFLICT!</span>`; 
                     row.classList.add('bg-red-100'); // Highlight the error row
                }

                row.innerHTML = `
                    <td class="p-2 text-gray-700">${date}</td>
                    <td class="p-2 font-semibold ${colorClass}">${activityText}</td>
                    <td class="p-2 text-gray-600">${startTime}</td>
                    <td class="p-2 text-gray-600">${endTime}</td>
                    <td class="p-2 text-right">${durationDisplay}</td>
                `;
            });
            
            logHistoryListEl.appendChild(table);
            
            // 3. Update the UI summary totals using the calculated raw milliseconds
            renderReportSummary(netWorkTimeFormatted, msToHours(totalBreakTimeMs));
        }
        
        // --- Render Main Log View based on isManagingLogs state ---
        function renderMainLogView() {
            if (isManagingLogs) {
                logViewTitleEl.textContent = 'Raw Log Events (Edit/Delete)';
                logFooterTextEl.textContent = 'Correcting these timestamps will automatically update the report.';
                manageLogsBtn.textContent = 'View Report Segments';
                renderRawLogEvents();
            } else {
                logViewTitleEl.textContent = 'Time Log Segments (For Reporting)';
                logFooterTextEl.textContent = 'Calculated time spans since the last report cutoff.';
                manageLogsBtn.textContent = 'Manage Log Events';
                renderTimeLogSegments(currentReportData.segments, currentReportData.totalWorkTimeMs, currentReportData.totalBreakTimeMs);
            }
        }
        
        // --- Log Management Handlers ---

        window.handleLogViewToggle = function() {
            isManagingLogs = !isManagingLogs;
            renderMainLogView();
        }

        window.handleEditEvent = function(logId, logType, logTimestamp) {
            const date = new Date(logTimestamp);
            
            // Format date to YYYY-MM-DD
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const dateValue = `${year}-${month}-${day}`;

            // Format time to HH:MM (24-hour)
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const timeValue = `${hours}:${minutes}`;

            // Populate the modal
            editingLogIdEl.value = logId;
            editingLogTypeEl.textContent = logType;
            editDateEl.value = dateValue;
            editTimeEl.value = timeValue;

            // Show the modal
            editLogModal.classList.remove('hidden');
            editLogModal.classList.add('flex');
        }

        window.handleSaveEdit = async function() {
            const logId = editingLogIdEl.value;
            const newDateStr = editDateEl.value;
            const newTimeStr = editTimeEl.value;
            
            if (!logId || !newDateStr || !newTimeStr) {
                showMessage("Input Error", "Please select both a valid date and time.", true);
                return;
            }

            // Combine date and time to create a new timestamp
            const newTimestampISO = new Date(`${newDateStr}T${newTimeStr}:00`).toISOString();

            hideEditModal();

            try {
                const logRef = doc(db, getTimeLogCollectionRef().path, logId);
                await updateDoc(logRef, {
                    timestamp: newTimestampISO
                });
                showMessage("Log Updated", `Successfully updated log event ID: ${logId.substring(0, 8)}...`, false);
            } catch (e) {
                console.error("Error updating log event:", e);
                showMessage("Update Failed", `Failed to update log event. Error: ${e.message}`, true);
            }
        }
        
        window.handleDeleteEvent = async function(logId, logType) {
            // NOTE: Using a custom modal instead of window.confirm
            if (!confirm(`Are you sure you want to delete the ${logType} event (ID: ${logId.substring(0, 8)}...)? This action cannot be undone and will affect your reports.`)) {
                return;
            }
            
            try {
                const logRef = doc(db, getTimeLogCollectionRef().path, logId);
                await deleteDoc(logRef);
                showMessage("Log Deleted", `Successfully deleted log event: ${logType}`, false);
            } catch (e) {
                console.error("Error deleting log event:", e);
                showMessage("Delete Failed", `Failed to delete log event. Error: ${e.message}`, true);
            }
        }
        
        // --- Firestore Path Functions (ALL PUBLIC/SHARED) ---
        
        function getReportStateRef() {
            const docPath = `artifacts/${appId}/public/data/state/report_cutoff`;
            return doc(db, docPath);
        }

        function getTimeLogCollectionRef() {
            const collectionPath = `artifacts/${appId}/public/data/timeLogs`;
            return collection(db, collectionPath);
        }

        function getClockStateRef() {
            const docPath = `artifacts/${appId}/public/data/state/clock_status`;
            return doc(db, docPath);
        }

        function getPublicTasksCollectionRef() {
            const collectionPath = `artifacts/${appId}/public/data/tasks`;
            return collection(db, collectionPath);
        }

        async function logTimeEvent(type) {
             if (!db || !userId) return;
             try {
                const logRef = getTimeLogCollectionRef();
                await addDoc(logRef, {
                    type: type,
                    timestamp: new Date().toISOString()
                });
            } catch (e) {
                console.error("Error logging time event:", e);
                showMessage("Log Error", `Failed to record ${type} event.`, true);
            }
        }
        
        /**
         * Sends the final report data to the Apps Script backend.
         * NOTE: This function requires the HTML to be served as a GAS Web App.
        */
        function sendReportDataToServer(reportData, timestamp) {
         if (typeof google === 'undefined' || !google.script || !google.script.run) {
           showMessage("Error", "Google Apps Script API not available. Cannot sync report.", true);
            return;
         }

          const netWorkMs = reportData.totalWorkTimeMs - reportData.totalBreakTimeMs;
          const netWorkTimeFormatted = msToHours(netWorkMs);

          const dataToSend = {
              cutoffTimestamp: timestamp,
              totalWorkHours: netWorkTimeFormatted,
              totalBreakHours: msToHours(reportData.totalBreakTimeMs)
           };

          // Call the backend GAS function
          google.script.run
             .withSuccessHandler(() => {
                 showMessage("Report Synced", "Report data successfully saved to the Google Sheet.", false);
             })
             .withFailureHandler(error => {
                  console.error("Backend Sync Failed:", error);
                  showMessage("Sync Failed", "Could not write data to Google Sheet. Check GAS logs.", true);
              })
             .recordFinalReport(dataToSend);
          }

        /**
         * Loads and listens for all real-time state changes from Firestore.
         */
        function loadStateFromFirestore() {
            if (!db || !userId) {
                console.error("Database or User ID is not initialized.");
                return;
            }
            
            // 1. Listen to the SHARED Clock/Break status
            const clockRef = getClockStateRef();
            onSnapshot(clockRef, async (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const sharedData = docSnapshot.data();
                    currentState.isClockedIn = sharedData.isClockedIn || false;
                    currentState.isUserOnBreak = sharedData.isUserOnBreak || false;
                } else {
                    await setDoc(clockRef, { isClockedIn: false, isUserOnBreak: false });
                }
                renderStatus(); 
            }, (error) => {
                console.error("Error setting up clock listener:", error);
            });

            // 2. Listen to the SHARED Report Cutoff Timestamp
            const reportStateRef = getReportStateRef();
            onSnapshot(reportStateRef, async (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const reportData = docSnapshot.data();
                    currentState.lastReportTimestamp = reportData.lastReportTimestamp || null; 
                } else {
                    await setDoc(reportStateRef, { lastReportTimestamp: null });
                }
                // When timestamp updates, the logs listener (4) will re-run automatically.
            }, (error) => {
                console.error("Error setting up report state listener:", error);
            });

            // 3. Listen to the SHARED Tasks
            const publicTasksRef = getPublicTasksCollectionRef();
            onSnapshot(query(publicTasksRef, orderBy("createdAt", "desc")), (querySnapshot) => {
                taskLoadingEl.textContent = '';
                taskLoadingEl.classList.add('hidden');
                
                const publicTasks = [];
                querySnapshot.forEach(doc => {
                    publicTasks.push({ id: doc.id, ...doc.data() });
                });
                currentState.tasks = publicTasks;
                renderTasks();
            }, (error) => {
                console.error("Error setting up public task listener:", error);
                taskLoadingEl.textContent = 'Error loading shared tasks.';
            });
            
            // 4. Listen to the SHARED Time Logs (FULL HISTORY)
            const logsQuery = query(getTimeLogCollectionRef(), orderBy("timestamp", "desc"));
            onSnapshot(logsQuery, (querySnapshot) => {
                historyLoadingEl.textContent = '';
                historyLoadingEl.classList.add('hidden');
                printReportBtn.disabled = false;
                markReportedBtn.disabled = false;
                
                const allLogs = [];
                querySnapshot.forEach(doc => {
                    // CRITICAL CHANGE: Capture the document ID
                    allLogs.push({ id: doc.id, ...doc.data() }); 
                });
                rawLogEvents = allLogs; // Store the raw events with IDs
                
                // Calculate time segments and totals based on current cutoff date
                // Note: calculateReportData sorts the logs internally by ascending timestamp
                const report = calculateReportData(allLogs, currentState.lastReportTimestamp);
                currentReportData = report; // Store the new calculated report data
                
                // Render the currently selected view (Segments or Raw Events)
                renderMainLogView();

            }, (error) => {
                console.error("Error setting up time log listener:", error);
                historyLoadingEl.textContent = 'Error loading session history.';
            });
        }

        async function saveSharedClockState() {
            if (!db) return;
            try {
                const clockRef = getClockStateRef();
                await setDoc(clockRef, {
                    isClockedIn: currentState.isClockedIn,
                    isUserOnBreak: currentState.isUserOnBreak
                });
            } catch (e) {
                console.error("Error saving shared clock state:", e);
                showMessage("Save Error", "Failed to save shared clock status to the cloud database.", true);
            }
        }
        
        // --- Task CRUD Operations (Same as before) ---

        window.toggleTaskCompletion = async function(taskId, currentStatus) {
            try {
                const taskRef = doc(db, getPublicTasksCollectionRef().path, taskId);
                await updateDoc(taskRef, {
                    isCompleted: !currentStatus
                });
            } catch (e) {
                console.error("Error toggling task completion:", e);
                showMessage("Task Error", "Failed to update task status.", true);
            }
        }

        window.deleteTask = async function(taskId) {
             try {
                const taskRef = doc(db, getPublicTasksCollectionRef().path, taskId);
                await deleteDoc(taskRef);
            } catch (e) {
                console.error("Error deleting task:", e);
                showMessage("Task Error", "Failed to delete task.", true);
            }
        }

        // --- Event Handlers (mostly same) ---
        
        window.handleClockToggle = async function() {
            const newState = !currentState.isClockedIn;
            
            if (currentState.isClockedIn && currentState.isUserOnBreak) {
                // If clocking out while on break, log break end and clock out
                await logTimeEvent('BREAK_END');
                await logTimeEvent('CLOCK_OUT');
                
                currentState.isClockedIn = false;
                currentState.isUserOnBreak = false;
                showMessage("Session Ended", "Clocked out and ended break (synced).", false);
            } else {
                const eventType = newState ? 'CLOCK_IN' : 'CLOCK_OUT';
                await logTimeEvent(eventType);
                currentState.isClockedIn = newState;
                if (!newState) {
                    currentState.isUserOnBreak = false; 
                }
                showMessage(newState ? "Clocked In (Synced)!" : "Clocked Out (Synced)!", `You are now ${newState ? 'working' : 'off'}.`, false);
            }
            saveSharedClockState();
        }

        window.handleBreakToggle = async function() {
            if (!currentState.isClockedIn) {
                showMessage("Action Blocked", "You must be clocked in to start or end a break.", true);
                return;
            }
            
            const newState = !currentState.isUserOnBreak;
            const eventType = newState ? 'BREAK_START' : 'BREAK_END';
            
            await logTimeEvent(eventType);
            currentState.isUserOnBreak = newState;
            
            showMessage(newState ? "Break Started (Synced)" : "Break Ended (Synced)", `Time logging is ${newState ? 'paused' : 'resumed'}.`, false);
            saveSharedClockState();
        }
        
        window.handleCalendarClick = function() {
            showDatePicker = !showDatePicker;
            if (showDatePicker) {
                dueDateContainerEl.classList.remove('hidden');
            } else {
                dueDateContainerEl.classList.add('hidden');
                newDueDateEl.value = ''; 
                newDueDate = null; 
            }
        }

        window.handleAddTask = async function() {
            const text = newTaskTextEl.value.trim();
            
            if (text.length < 3) {
                showMessage("Input Required", "Please enter a task description that is at least 3 characters long.", true);
                return;
            }
            
            if (!db || !userId) {
                showMessage("DB Error", "Authentication not ready. Cannot add task.", true);
                return;
            }
            
            try {
                const publicTasksRef = getPublicTasksCollectionRef();
                await addDoc(publicTasksRef, {
                    text: text,
                    isCompleted: false,
                    ownerId: userId,
                    createdAt: new Date(),
                    dueDate: newDueDate || null 
                });
                
                newTaskTextEl.value = '';
                newDueDateEl.value = '';
                newDueDate = null;
                showDatePicker = false;
                dueDateContainerEl.classList.add('hidden'); 
                
                showMessage("Task Added", `Synced task '${text}' added!`, false);
            } catch (e) {
                console.error("Error adding public task:", e);
                showMessage("Save Error", "Failed to save public task.", true);
            }
        }
        
        window.handlePrintReport = function() {
            // This function triggers the print dialogue, relying on the @media print CSS to format the output.
            window.print();
        }

        window.handleMarkReported = async function() {
            if (!db || !userId) return;
            const now = new Date().toISOString();
            try {
                sendReportDataToServer(currentReportData, now);
                const reportStateRef = getReportStateRef();

                await updateDoc(reportStateRef, {
                    lastReportTimestamp: now
                });
                
                showMessage("Report Cleared", "All current hours have been marked as reported. The report summary is reset.", false);

            } catch (e) {
                console.error("Error marking hours as reported:", e);
                showMessage("Report Error", `Failed to mark hours as reported: ${e.message}`, true);
            }
        }


        /**
         * Handles the entire Firebase initialization and authentication process.
         */
        async function initializeFirebaseAndAuth() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                await setPersistence(auth, browserLocalPersistence);

                if (typeof __initial_auth_token === 'string' && __initial_auth_token.length > 0) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        userIdDisplayEl.textContent = userId;
                        userIdDisplayEl.classList.remove('loading-text', 'loading-shimmer');
                        
                        clockToggleBtn.disabled = false;
                        breakToggleBtn.disabled = false;
                        addTaskBtn.disabled = false;
                        printReportBtn.disabled = false;
                        markReportedBtn.disabled = false;
                        manageLogsBtn.disabled = false;
                        
                        loadStateFromFirestore(); 
                    } else {
                        userIdDisplayEl.textContent = 'Signed Out';
                        console.error("User is signed out. Cannot access database.");
                    }
                });
            } catch (e) {
                console.error("Firebase Initialization Error:", e);
                userIdDisplayEl.textContent = 'Error (DB Failed)';
                userIdDisplayEl.classList.remove('loading-text', 'loading-shimmer');
                showMessage("Initialization Failed", `Could not connect to Firebase: ${e.message}. The app is non-functional.`, true);
            }
        }

        
        
        // Start the application initialization when the window loads.
        window.onload = initializeFirebaseAndAuth;
    </script>
</body>
</html>
</body>
</html>